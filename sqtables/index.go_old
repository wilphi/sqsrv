package sqtables

import (
	"fmt"
	"sort"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/wilphi/sqsrv/sqerr"
	"github.com/wilphi/sqsrv/sqprofile"
	"github.com/wilphi/sqsrv/sqtypes"
)

type idxElem struct {
	V   []sqtypes.Value
	Ptr int
}

type elementArray []idxElem

// Index -
type Index struct {
	name        string
	elemArray   elementArray
	colHasNulls bool
	col         []column.Ref
}

func (ea elementArray) Len() int {
	return len(ea)
}
func (ea elementArray) Swap(i, j int) {
	ea[i], ea[j] = ea[j], ea[i]
}
func (ea elementArray) Less(i, j int) bool {
	x := 0
	for {
		if x >= len(ea[i].V) {
			// all values are equal
			break
		}
		if ea[i].V[x].LessThan(ea[j].V[x]) {
			return true
		}
		if ea[i].V[x].GreaterThan(ea[j].V[x]) {
			return false
		}
		// equal so test next level
		x++
	}
	return false
}

// AddElement -
//func (idx *Index) AddElement(v []sqtypes.Value, ptr int) error {
func (idx *Index) AddElement(d *DataSet) error {

	// make sure each index col is in the dataset
	dColList := d.GetColList()
	colMap := make([]int, len(idx.col))
	for i, col := range idx.col {
		colMap[i] = dColList.FindColIdx(col.ColName)
		if colMap[i] < 0 {
			return sqerr.Newf("Index column %q was not found in DataSet", col.ColName))
		}
	}

	for i := range d.Vals {
		// values type must match index
		for j := range idx.col {
			if idx.col[j].ColType != d.Vals[i][j].Type() {
				return sqerr.New("Values added to index must match Column type")
			}
		}
		idx.elemArray = append(idx.elemArray, idxElem{V: d.Vals[i], Ptr: d.Ptrs[i]})
	}
	sort.Sort(idx.elemArray)
	idx.ToString()
	return nil
}

// ToString -
func (idx Index) ToString() string {
	str := fmt.Sprintf("Index %s on: ", idx.name)
	for _, c := range idx.col {
		str += fmt.Sprintf(" %s,", c.ColName)
	}
	str = strings.TrimRight(str, ",") + "\n"

	for _, e := range idx.elemArray {
		str += "\t"
		for _, i := range e.V {
			str += "\t" + i.ToString()
		}
		str += fmt.Sprintf(" \t|| Pointer: %8d\n", e.Ptr)
	}
	return str
}

// IsSorted - used for testing
func (idx Index) IsSorted() bool {
	return sort.IsSorted(idx.elemArray)
}

// NewIndex - Create a new Index based on dataset
func NewIndex(profile *sqprofile.SQProfile, name string, dataSet *DataSet) (*Index, error) {
	// Unpack required data from the DataSet
	tab := dataSet.GetTable()
	colList := dataSet.GetColList()
	col := colList.GetColDefs()

	// Make sure that all columns in list exist in table
	err := colList.ValidateTable(profile, tab)
	if err != nil {
		return nil, err
	}

	idx := Index{name: name, col: col, colHasNulls: false}

	colMap := make(map[string]bool)

	for _, c := range col {
		if ret, _ := tab.FindCol(profile, c.ColName); ret < 0 {
			return nil, sqerr.Newf("Create Index: Column %s does not exist in table %s", c.ColName, tab.GetName(profile)))
		}
		if colMap[c.ColName] {
			return nil, sqerr.Newf("Create Index: Column %s can not occur more than once in index %s", c.ColName, name))
		}
		colMap[c.ColName] = true
	}
	if dataSet.Vals == nil || dataSet.Ptrs == nil {

		return nil, sqerr.NewInternal("ColData and ColPtr do not match. At least one is nil")
	}
	if len(dataSet.Vals) != len(dataSet.Ptrs) {
		return nil, sqerr.NewInternal("length of Col data and pointer arrays do not match")
	}

	for i, row := range dataSet.Vals {
		for _, val := range row {
			if val.Type() == "(Null)" {
				// Null values cannot be indexed
				idx.colHasNulls = true
				break
			}
		}
		elem := idxElem{V: row, Ptr: dataSet.Ptrs[i]}
		idx.elemArray = append(idx.elemArray, elem)

	}
	fmt.Println(idx.ToString())

	// sort the index
	sort.Sort(idx.elemArray)
	str := ""
	for _, c := range col {
		str += c.ColName + ", "
	}
	str = strings.TrimRight(str, ", ")
	log.Infof("Index %q created on table %s column(s) %s", name, tab.GetName(profile), str)
	fmt.Println(idx.ToString())
	return &idx, nil
}
